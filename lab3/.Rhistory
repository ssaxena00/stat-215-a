}
X_bin <- X %>% select(-long, -lat)
#model <- RcppML::nmf(X_bin, k=3)
clusters <- dclust(t(X_bin), min_samples = 8000, min_dist = 0.001, seed = 10)
groups <- list()
for (i in c(1:3)) {
for (j in clusters[[i]]$samples) {
groups[j] <- i
}
}
data <- X[-1, (1:470)] %>% mutate(cluster = groups)
data <- as.data.frame(lapply(data, unlist))
ggplot(data) +
geom_point(aes(x = long, y = lat, color = as.factor(cluster)), alpha = 0.5) +
geom_polygon(data = state_df, aes(x = long, y = lat, group = group), color = "black", fill = NA) +
labs(color = "Cluster") +
theme_void()
X_bin <-  Y[, 1:2] %>% select(-long, -lat)
X_bin <- X %>% select(-long, -lat)
#model <- RcppML::nmf(X_bin, k=3)
clusters <- dclust(t(X_bin), min_samples = 8000, min_dist = 0.001, seed = 10)
groups <- list()
for (i in c(1:3)) {
for (j in clusters[[i]]$samples) {
groups[j] <- i
}
}
data <- X[-1, (1:470)] %>% mutate(cluster = groups)
data <- as.data.frame(lapply(data, unlist))
ggplot(data) +
geom_point(aes(x = long, y = lat, color = as.factor(cluster)), alpha = 0.5) +
geom_polygon(data = state_df, aes(x = long, y = lat, group = group), color = "black", fill = NA) +
labs(color = "Cluster") +
theme_void()
X_bin <- X %>% select(-long, -lat)
#model <- RcppML::nmf(X_bin, k=3)
clusters <- dclust(t(X_bin), min_samples = 8000, min_dist = 0.001, seed = 10)
groups <- list()
for (i in c(1:3)) {
for (j in clusters[[i]]$samples) {
groups[j] <- i
}
}
data <- X[-1, (1:470)] %>% mutate(cluster = groups)
ggplot(data) +
geom_point(aes(x = long, y = lat, color = as.factor(cluster)), alpha = 0.5) +
geom_polygon(data = state_df, aes(x = long, y = lat, group = group), color = "black", fill = NA) +
labs(color = "Cluster") +
theme_void()
X_bin <- X %>% select(-long, -lat)
#model <- RcppML::nmf(X_bin, k=3)
clusters <- dclust(t(X_bin), min_samples = 8000, min_dist = 0.001, seed = 10)
groups <- list()
for (i in c(1:3)) {
for (j in clusters[[i]]$samples) {
groups[j] <- i
}
}
data <- X[-1, (1:470)] %>% mutate(cluster = groups)
data <- as.data.frame(lapply(data, unlist))
ggplot(data) +
geom_point(aes(x = long, y = lat, color = as.factor(cluster)), alpha = 0.5) +
geom_polygon(data = state_df, aes(x = long, y = lat, group = group), color = "black", fill = NA) +
labs(color = "Cluster") +
theme_void()
# load in useful packages
library(tidyverse)
library(forcats)
library(lubridate)
library(stringr)
require(gridExtra)
library(viridis)
library(RcppML)
library(Rcpp)
# require(devtools)
#install.packages('textfeatures', version='0.2.0', repos='http://cran.us.r-project.org')
# set default knitr chunks
knitr::opts_chunk$set(
echo = FALSE,  # don't print the code chunk
warning = FALSE,  # don't print warnings
message = FALSE,  # don't print messages
fig.width = 6,  # set default width of figures
fig.height = 4,  # set default height of figures
fig.align = "center",  # always align figure in center
fig.pos = "H",  # always plot figure at the exact location of the code chunk
cache = FALSE)  # don't cache results
source("R/load.R")
source("R/clean.R")
ling_data_orig <- loadLingData()
ling_location_orig <- loadLingLocation()
# quest.use: questions in words
# all.ans: maps letter answer to word answer for each question
load("data/question_data.RData")
ling_data <- cleanLingData(ling_data_orig)
ling_location <- cleanLingLocation(ling_location_orig)
state_df <- map_data("state")
responses_1 <- getDataForQuestion(ling_data, "073", c(1,6))
responses_2 <- getDataForQuestion(ling_data, "103", c(1,3,4))
plot1 <- plotMap(responses_1, state_df, "(Q73)")
plot2 <- plotMap(responses_2, state_df, "(Q103)")
grid.arrange(plot1, plot2, nrow=2)
col_names <- colnames(ling_data)[5:71]
x <- lapply(col_names, function(x) convertToBinary(x, ling_data))
X <- do.call(cbind, x) %>%
mutate(long = ling_data$long, lat = ling_data$lat)
Y <- rotateData(X)
X_bin <- X %>% select(-long, -lat)
#model <- RcppML::nmf(X_bin, k=3)
clusters <- dclust(t(X_bin), min_samples = 8000, min_dist = 0.001, seed = 10)
groups <- list()
for (i in c(1:3)) {
for (j in clusters[[i]]$samples) {
groups[j] <- i
}
}
data <- X[-1, (1:470)] %>% mutate(cluster = groups)
data <- as.data.frame(lapply(data, unlist))
ggplot(data) +
geom_point(aes(x = long, y = lat, color = as.factor(cluster)), alpha = 0.5) +
geom_polygon(data = state_df, aes(x = long, y = lat, group = group), color = "black", fill = NA) +
labs(color = "Cluster") +
theme_void()
# run k-means 4 times
kmeans_runs <- lapply(1:4, function(x){kmeans(Y[, 1:2], centers = 3)})
# plot kmeans clusters on the map
plots <- lapply(kmeans_runs, plotKmeans, data = Y, alpha = .5, sample_rate = .2)
# show plot
grid.arrange(plots[[1]], plots[[2]], plots[[3]], plots[[4]],
ncol = 2, nrow = 2)
Y_downsampled <- X %>%
sample_frac(.5) %>%
rotateData()
kmeans_downsampled <- kmeans(Y_downsampled[, 1:2], centers = 3)
plotKmeans(kmeans_downsampled, Y_downsampled, alpha = .5,  sample_rate = .2)
Y_downsampled <- X %>%
sample_frac(.5) %>%
rotateData()
kmeans_downsampled <- kmeans(Y_downsampled[, 1:2], centers = 3)
plotKmeans(kmeans_downsampled, Y_downsampled, alpha = .5,  sample_rate = .2)
Y_removed <- X %>%
select(-starts_with("q073"), -starts_with("q050")) %>%
rotateData()
kmeans_removed <- kmeans(Y_removed[, 1:2], centers = 3)
p2 <- plotKmeans(kmeans_removed, Y_removed, alpha = .5, sample_rate = .2)
Y_removed <- X %>%
select(-starts_with("q073"), -starts_with("q050")) %>%
rotateData()
kmeans_removed <- kmeans(Y_removed[, 1:2], centers = 3)
plotKmeans(kmeans_removed, Y_removed, alpha = .5, sample_rate = .2)
Y_ling_location <- ling_location %>%
select(-n, -lat, -long) %>%
mutate_all(funs(./ling_location$n)) %>%
mutate(lat = ling_location$lat, long = ling_location$long) %>%
rotateData()
kmeans_ling_location <- Y_ling_location[, 1:2] %>%
kmeans(centers = 3)
plotKmeans(kmeans_ling_location, Y_ling_location, alpha = 1, sample_rate = 1)}
Y_ling_location <- ling_location %>%
select(-n, -lat, -long) %>%
mutate_all(funs(./ling_location$n)) %>%
mutate(lat = ling_location$lat, long = ling_location$long) %>%
rotateData()
kmeans_ling_location <- Y_ling_location[, 1:2] %>%
kmeans(centers = 3)
plotKmeans(kmeans_ling_location, Y_ling_location, alpha = 1, sample_rate = 1)
setwd("~/Desktop/stat-215-a/lab3/R")
setwd("~/Desktop/stat-215-a/lab3")
source('~/Desktop/stat-215-a/lab3/R/similarity.R')
Rcpp::sourceCpp('R/similarity.cpp')
Rcpp::sourceCpp('R/similarity.cpp')
Rcpp::sourceCpp('R/similarity.cpp')
Rcpp::sourceCpp('R/similarity.cpp')
# load in useful packages
library(tidyverse)
library(forcats)
library(lubridate)
library(stringr)
require(gridExtra)
library(viridis)
library(RcppML)
library(Rcpp)
# set default knitr chunks
knitr::opts_chunk$set(
echo = FALSE,  # don't print the code chunk
warning = FALSE,  # don't print warnings
message = FALSE,  # don't print messages
fig.width = 6,  # set default width of figures
fig.height = 4,  # set default height of figures
fig.align = "center",  # always align figure in center
fig.pos = "H",  # always plot figure at the exact location of the code chunk
cache = FALSE)  # don't cache results
# load lingBinary. The columns are: ID, CITY, STATE, ZIP, lat, long, questions...
# 467 columns, 45,152 rows
load("data/lingBinary.RData")
View(lingBinary)
load("data/lingBinary.RData")
# lingBinary: 474 columns, 45,152 rows
# columns: ID, CITY, STATE, ZIP, lat, long, questions...
# only keep the ID and questions columns in data
data <- lingBinary %>%
select(-CITY, -STATE, -ZIP, -lat, -long)
# load in useful packages
library(tidyverse)
library(forcats)
library(lubridate)
library(stringr)
require(gridExtra)
library(viridis)
library(RcppML)
library(Rcpp)
# set default knitr chunks
knitr::opts_chunk$set(
echo = FALSE,  # don't print the code chunk
warning = FALSE,  # don't print warnings
message = FALSE,  # don't print messages
fig.width = 6,  # set default width of figures
fig.height = 4,  # set default height of figures
fig.align = "center",  # always align figure in center
fig.pos = "H",  # always plot figure at the exact location of the code chunk
cache = FALSE)  # don't cache results
source("R/similarity.R")
sourceCpp("R/similarity.cpp")
load("data/lingBinary.RData")
# lingBinary: 474 columns, 45,152 rows
# columns: ID, CITY, STATE, ZIP, lat, long, questions...
# only keep the ID and questions columns in data
data <- lingBinary %>%
select(-CITY, -STATE, -ZIP, -lat, -long)
View(data)
install.packages('microbenchmark')
# load in useful packages
library(tidyverse)
library(forcats)
library(lubridate)
library(stringr)
require(gridExtra)
library(Rcpp)
# set default knitr chunks
knitr::opts_chunk$set(
echo = FALSE,  # don't print the code chunk
warning = FALSE,  # don't print warnings
message = FALSE,  # don't print messages
fig.width = 6,  # set default width of figures
fig.height = 4,  # set default height of figures
fig.align = "center",  # always align figure in center
fig.pos = "H",  # always plot figure at the exact location of the code chunk
cache = FALSE)  # don't cache results
# source similarity functions
source("R/similarity.R")
sourceCpp("R/similarity.cpp")
# compare the R and C++ implementations of similarity over random samples
n <- 5000 # sample size
compare_time <- function(k) {
x1 <- sample(1:k, n, replace = TRUE) # vector 1
x2 <- sample(1:k, n, replace = TRUE) # vector 2
start_r <- proc.time() # start timer for R
sim_r <- similarity(x1, x2)
r_time <- proc.time() - start_r
start_cpp <- proc.time() # start timer for Cpp
sim_cpp <- similarityRcpp(x1, x2)
cpp_time <- proc.time() - start_cpp
return(r_time, cpp_time)
}
compare_time(3)
source('~/Desktop/stat-215-a/lab3/R/similarity.R')
# compare the R and C++ implementations of similarity over random samples
n <- 5000 # sample size
compare_time <- function(k) {
x1 <- sample(1:k, n, replace = TRUE) # vector 1
x2 <- sample(1:k, n, replace = TRUE) # vector 2
start_r <- proc.time() # start timer for R
sim_r <- similarity(x1, x2)
r_time <- proc.time() - start_r
start_cpp <- proc.time() # start timer for Cpp
sim_cpp <- similarityRcpp(x1, x2)
cpp_time <- proc.time() - start_cpp
return(r_time, cpp_time)
}
compare_time(3)
# load in useful packages
library(tidyverse)
library(forcats)
library(lubridate)
library(stringr)
require(gridExtra)
library(Rcpp)
# set default knitr chunks
knitr::opts_chunk$set(
echo = FALSE,  # don't print the code chunk
warning = FALSE,  # don't print warnings
message = FALSE,  # don't print messages
fig.width = 6,  # set default width of figures
fig.height = 4,  # set default height of figures
fig.align = "center",  # always align figure in center
fig.pos = "H",  # always plot figure at the exact location of the code chunk
cache = FALSE)  # don't cache results
# source similarity functions
source("R/similarity.R")
sourceCpp("R/similarity.cpp")
# compare the R and C++ implementations of similarity over random samples
n <- 5000 # sample size
compare_time <- function(k) {
x1 <- sample(1:k, n, replace = TRUE) # vector 1
x2 <- sample(1:k, n, replace = TRUE) # vector 2
start_r <- proc.time() # start timer for R
sim_r <- similarity(x1, x2)
r_time <- proc.time() - start_r
start_cpp <- proc.time() # start timer for Cpp
sim_cpp <- similarityRcpp(x1, x2)
cpp_time <- proc.time() - start_cpp
return(r_time, cpp_time)
}
compare_time(3)
source('~/Desktop/stat-215-a/lab3/R/similarity.R')
source('~/Desktop/stat-215-a/lab3/R/similarity.R')
source('~/Desktop/stat-215-a/lab3/R/similarity.R')
# load in useful packages
library(tidyverse)
library(forcats)
library(lubridate)
library(stringr)
require(gridExtra)
library(Rcpp)
# set default knitr chunks
knitr::opts_chunk$set(
echo = FALSE,  # don't print the code chunk
warning = FALSE,  # don't print warnings
message = FALSE,  # don't print messages
fig.width = 6,  # set default width of figures
fig.height = 4,  # set default height of figures
fig.align = "center",  # always align figure in center
fig.pos = "H",  # always plot figure at the exact location of the code chunk
cache = FALSE)  # don't cache results
# source similarity functions
source("R/similarity.R")
sourceCpp("R/similarity.cpp")
# compare the R and C++ implementations of similarity over random samples
n <- 5000 # sample size
compare_time <- function(k) {
x1 <- sample(1:k, n, replace = TRUE) # vector 1
x2 <- sample(1:k, n, replace = TRUE) # vector 2
start_r <- proc.time() # start timer for R
sim_r <- similarity(x1, x2)
r_time <- proc.time() - start_r
start_cpp <- proc.time() # start timer for Cpp
sim_cpp <- similarityRcpp(x1, x2)
cpp_time <- proc.time() - start_cpp
return(r_time, cpp_time)
}
compare_time(3)
source('~/Desktop/stat-215-a/lab3/R/similarity.R')
# load in useful packages
library(tidyverse)
library(forcats)
library(lubridate)
library(stringr)
require(gridExtra)
library(Rcpp)
# set default knitr chunks
knitr::opts_chunk$set(
echo = FALSE,  # don't print the code chunk
warning = FALSE,  # don't print warnings
message = FALSE,  # don't print messages
fig.width = 6,  # set default width of figures
fig.height = 4,  # set default height of figures
fig.align = "center",  # always align figure in center
fig.pos = "H",  # always plot figure at the exact location of the code chunk
cache = FALSE)  # don't cache results
# source similarity functions
source("R/similarity.R")
sourceCpp("R/similarity.cpp")
# compare the R and C++ implementations of similarity over random samples
n <- 5000 # sample size
compare_time <- function(k) {
x1 <- sample(1:k, n, replace = TRUE) # vector 1
x2 <- sample(1:k, n, replace = TRUE) # vector 2
start_r <- proc.time() # start timer for R
sim_r <- similarity(x1, x2)
r_time <- proc.time() - start_r
start_cpp <- proc.time() # start timer for Cpp
sim_cpp <- similarityRcpp(x1, x2)
cpp_time <- proc.time() - start_cpp
return(r_time, cpp_time)
}
compare_time(3)
# compare the R and C++ implementations of similarity over random samples
n <- 5000 # sample size
compare_time <- function(k) {
x1 <- sample(1:k, n, replace = TRUE) # vector 1
x2 <- sample(1:k, n, replace = TRUE) # vector 2
start_r <- proc.time() # start timer for R
sim_r <- similarity(x1, x2)
r_time <- proc.time() - start_r
start_cpp <- proc.time() # start timer for Cpp
sim_cpp <- similarityRcpp(x1, x2)
cpp_time <- proc.time() - start_cpp
return(list(r_time, cpp_time))
}
compare_time(3)
# compare the R and C++ implementations of similarity over random samples
n <- 5000 # sample size
compare_time <- function(k) {
x1 <- sample(1:k, n, replace = TRUE) # vector 1
x2 <- sample(1:k, n, replace = TRUE) # vector 2
start_r <- proc.time() # start timer for R
sim_r <- similarity(x1, x2)
r_time <- proc.time() - start_r
start_cpp <- proc.time() # start timer for Cpp
sim_cpp <- similarityRcpp(x1, x2)
cpp_time <- proc.time() - start_cpp
return(list(r_time, cpp_time))
}
compare_time(3)[1]
# compare the R and C++ implementations of similarity over random samples
n <- 5000 # sample size
compare_time <- function(k) {
x1 <- sample(1:k, n, replace = TRUE) # vector 1
x2 <- sample(1:k, n, replace = TRUE) # vector 2
start_r <- proc.time() # start timer for R
sim_r <- similarity(x1, x2)
r_time <- proc.time() - start_r
start_cpp <- proc.time() # start timer for Cpp
sim_cpp <- similarityRcpp(x1, x2)
cpp_time <- proc.time() - start_cpp
return(list(r_time, cpp_time))
}
compare_time(3)[1]['elapsed']
# compare the R and C++ implementations of similarity over random samples
n <- 5000 # sample size
compare_time <- function(k) {
x1 <- sample(1:k, n, replace = TRUE) # vector 1
x2 <- sample(1:k, n, replace = TRUE) # vector 2
start_r <- proc.time() # start timer for R
sim_r <- similarity(x1, x2)
r_time <- proc.time() - start_r
start_cpp <- proc.time() # start timer for Cpp
sim_cpp <- similarityRcpp(x1, x2)
cpp_time <- proc.time() - start_cpp
return(list(r_time, cpp_time))
}
compare_time(3)[1]
# compare the R and C++ implementations of similarity over random samples
n <- 5000 # sample size
compare_time <- function(k) {
x1 <- sample(1:k, n, replace = TRUE) # vector 1
x2 <- sample(1:k, n, replace = TRUE) # vector 2
start_r <- proc.time() # start timer for R
sim_r <- similarity(x1, x2)
r_time <- proc.time() - start_r
start_cpp <- proc.time() # start timer for Cpp
sim_cpp <- similarityRcpp(x1, x2)
cpp_time <- proc.time() - start_cpp
return(list(r_time, cpp_time))
}
ans <- compare_time(3)
ans[1]
ans[2]
# compare the R and C++ implementations of similarity over random samples
n <- 5000 # sample size
compare_time <- function(k) {
x1 <- sample(1:k, n, replace = TRUE) # vector 1
x2 <- sample(1:k, n, replace = TRUE) # vector 2
start_r <- proc.time() # start timer for R
sim_r <- similarity(x1, x2)
r_time <- proc.time() - start_r
start_cpp <- proc.time() # start timer for Cpp
sim_cpp <- similarityRcpp(x1, x2)
cpp_time <- proc.time() - start_cpp
return(list(r_time, cpp_time))
}
ans <- compare_time(4)
ans[2]
ans[1]
# compare the R and C++ implementations of similarity over random samples
n <- 5000 # sample size
compare_time <- function(k) {
x1 <- sample(1:k, n, replace = TRUE) # vector 1
x2 <- sample(1:k, n, replace = TRUE) # vector 2
start_r <- proc.time() # start timer for R
sim_r <- similarity(x1, x2)
r_time <- proc.time() - start_r
start_cpp <- proc.time() # start timer for Cpp
sim_cpp <- similarityRcpp(x1, x2)
cpp_time <- proc.time() - start_cpp
return(list(r_time, cpp_time))
}
ans <- compare_time(4)
# compare the R and C++ implementations of similarity over random samples
n <- 5000 # sample size
compare_time <- function(k) {
x1 <- sample(1:k, n, replace = TRUE) # vector 1
x2 <- sample(1:k, n, replace = TRUE) # vector 2
start_r <- proc.time() # start timer for R
sim_r <- similarity(x1, x2)
r_time <- proc.time() - start_r
start_cpp <- proc.time() # start timer for Cpp
sim_cpp <- similarityRcpp(x1, x2)
cpp_time <- proc.time() - start_cpp
return(list(r_time, cpp_time))
}
ans <- compare_time(5)
ans[1]
ans[2]
View(data)
source('~/Desktop/stat-215-a/lab3/R/full_algorithm.R')
source('~/Desktop/stat-215-a/lab3/R/full_algorithm.R')
source('~/Desktop/stat-215-a/lab3/R/full_algorithm.R')
source('~/Desktop/stat-215-a/lab3/R/full_algorithm.R')
# load cpp file for computing similarity
sourceCpp('R/similarity.cpp')
source('~/Desktop/stat-215-a/lab3/R/full_algorithm.R')
View(fullKmeansTest)
